/******************************************************************************
 * File: terminate_child_with_signals.c
 * 
 * Purpose:
 * This program demonstrates how a **parent process** can terminate or abort a 
 * **child process** using the signals **SIGKILL**, **SIGTERM**, and **SIGINT**. 
 * The program creates a child process using **fork()**. The parent 
 * process sends signals to the child to terminate or handle signals. The child 
 * is set up to handle signals like **SIGTERM** and **SIGINT** (Ctrl+C).
 * 
 * Key Concepts Demonstrated:
 * 1. **fork()**: Creating a child process from the parent process.
 * 2. **kill()**: Sending signals to the child process from the parent.
 * 3. **SIGKILL**: A signal used to immediately terminate the child process, 
 *    which cannot be caught or handled by the child.
 * 4. **SIGTERM**: A signal used to request termination, allowing the process 
 *    to perform cleanup and exit gracefully.
 * 5. **SIGINT**: Signal generated by pressing Ctrl+C (interrupt), which can 
 *    be caught and handled by the child allowing it to perform cleanup and exit gracefully.
 * 6. **signal()**: Registering signal handlers for different signals in the 
 *    child process.
 * 7. Understanding how a parent can manage, terminate, and signal the child process.
 * 
 * Program Execution:
 * - The parent creates a child process using **fork()**.
 * - The parent can send **SIGKILL**, **SIGTERM**, or **SIGINT** to control the 
 *   child's behavior.
 * - The child handles **SIGTERM** and **SIGINT**, printing messages when it 
 *   catches these signals.
 * - The program demonstrates signal handling in child and parent processes.
 * 
 * Output:
 * - The program shows the **PID** of both the parent and child.
 * - The parent process will terminate the child process with **SIGKILL**, 
 *   **SIGTERM**, or **SIGINT** depending on the selected signal.
 * - The child will handle **SIGTERM** and **SIGINT** gracefully, but **SIGKILL** 
 *   cannot be handled by the child.
 * 
 * Usage:
 * - Compile: gcc terminate_child_with_signals.c -o process
 * - Execute: ./process
 * 
 * Learning Objectives for Students:
 * 1. Understand how signals work and how they can be handled by processes.
 * 2. Learn how the **kill()** system call works to send signals between processes.
 * 3. Observe how different signals, such as **SIGKILL**, **SIGTERM**, and **SIGINT**, 
 *    affect the child process.
 * 4. Understand how to register signal handlers using **signal()** in C.
 * 
 * Experimentation Instructions:
 * 1. Observe the output of the program to see how the child responds to **SIGTERM**, 
 *    **SIGINT** and **SIGKILL**.
 * 3. Modify the program to handle more signals or add additional behavior to the child.
 * 4. Change the sleep duration in the child process to see how the signals affect 
 *    the termination.
 * 5. Try sending signals to the child using the **kill** command from the terminal.
 *  
 *  
 *****************************************************************************/

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/wait.h>  // For wait()
#include <sys/types.h> // For pid_t
#include <signal.h>     // For signal handling and kill()

// Signal handler function for SIGTERM and SIGINT
void signal_handler(int sig) 
{
    if (sig == SIGTERM) 
    {
        printf("Child: Caught SIGTERM, terminating GRACEFULLY...\n");
        exit(0); // Gracefully terminate the child process
    } 
    else if (sig == SIGINT) 
    {
        printf("Child: Caught SIGINT (Ctrl+C), terminating GRACEFULLY...\n");
        exit(0); // Gracefully terminate the child process
    }
}

int main() 
{
    int status; // Status of the child process
    pid_t pid = fork(); // Create a child process

    if (pid == 0) 
    {  // Child process
        // Set up and register signal handlers
        signal(SIGTERM, signal_handler); // Handle SIGTERM
        signal(SIGINT, signal_handler);  // Handle SIGINT (Ctrl+C)

        printf("Child: I'm the child process. My PID = %d\n", getpid());
        
        // Simulate the child not exiting on its own and being stuck in a loop
        while (1) 
        {
            sleep(1); // Sleep for 1 second
            printf("Child: Now I am going to RUN FOREVER !!!!!\n");
        }
    } 
    else 
    {  // Parent process
        printf("Parent: I'm the parent process. My PID = %d\n", getpid());
        printf("Parent: Going to wait for 5 seconds before sending signals to the child...\n");
        
        sleep(5);  // Sleep for 5 seconds
        
        // Uncomment one of the following signal blocks to send different signals to the child:

        // Send SIGKILL to immediately terminate the child (child cannot handle SIGKILL)
         printf("Parent: Sending SIGKILL to terminate the child immediately...\n");
         printf("BEWARE: Child will not be able to handle SIGKILL signal, hence NO GRACEFUL TERMINATION possible!!!\n");
         kill(pid, SIGKILL); // Send SIGKILL signal to the child process
        
        // printf("\nParent: Sending SIGTERM to gracefully terminate the child...\n");
        // kill(pid, SIGTERM);  // Send SIGTERM signal to the child

        // Press Ctrl+C in the terminal while child is executing (within 5 seconds) 
        // to send SIGINT to the child
        // printf("\nParent: Sending SIGINT (Ctrl+C) to the child...\n");
        // kill(pid, SIGINT);  // Send SIGINT signal to the child

        // Wait for the child process to terminate
        waitpid(pid, &status, 0);  // Parent waits for the child to terminate
        
        printf("Parent: Child has been terminated. Parent exiting...\n");
    }

    return 0;
}